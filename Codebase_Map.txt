################################################################################
# DIRECTORY STRUCTURE (Smart Filtered)
################################################################################
dsa_sem_proj
+--- requirements.txt
+--- structures.py
+--- nust_raw.osm
+--- pois.json
+--- test_structures.py
+--- visualizer.py
+--- test.ps1
+--- test_algorithms.py
+--- nodes.json
+--- Codebase_Map.txt
+--- data_pipeline.py
+--- .gitignore
+--- algorithms.py
+--- main.py
+--- map.html
+--- DSA_SemesterProject_Proposal_MuhammadMusaabUlHaq_501739_AhmedHassanRaza_511263_UsmanAmjad_516261_FaridaMohammadi_534534.pdf
\--- edges.json

################################################################################
# FILE START: D:\dsa_sem_proj\algorithms.py
################################################################################

import math
from structures import MinHeap

METERS_PER_DEG_LAT = 111000
METERS_PER_DEG_LON = 93000 

# STRICT ADMISSIBILITY CONSTANTS
MAX_CAR_SPEED = 34.0 
MAX_WALK_SPEED = 2.0 

def get_distance_meters(node_a, node_b):
    d_lat = (node_a['lat'] - node_b['lat']) * METERS_PER_DEG_LAT
    d_lon = (node_a['lon'] - node_b['lon']) * METERS_PER_DEG_LON
    return math.sqrt(d_lat**2 + d_lon**2)

def heuristic_time(node_a, node_b, mode='car'):
    dist = get_distance_meters(node_a, node_b)
    if mode == 'car':
        return dist / MAX_CAR_SPEED
    else:
        return dist / MAX_WALK_SPEED

def get_tobler_time(dist, elev_diff):
    if dist == 0: return 0
    slope = elev_diff / dist
    # Tobler's Hiking Function
    speed_kmh = 6 * math.exp(-3.5 * abs(slope + 0.05))
    speed_ms = speed_kmh / 3.6
    return dist / speed_ms

def a_star_search(graph, start_id, end_id, mode='car'):
    open_set = MinHeap()
    open_set.push((0, start_id)) 
    came_from = {} 
    
    g_score = {node_id: float('inf') for node_id in graph.nodes}
    g_score[start_id] = 0
    
    f_score = {node_id: float('inf') for node_id in graph.nodes}
    f_score[start_id] = heuristic_time(graph.nodes[start_id], graph.nodes[end_id], mode)

    while not open_set.is_empty():
        current_f, current_id = open_set.pop()
        
        if current_id == end_id:
            return reconstruct_path(came_from, current_id), g_score[end_id]

        # --- FIX IS HERE ---
        # We now unpack 6 values. The last two are geometry and highway_type, which we ignore with _
        neighbors = graph.get_neighbors(current_id)
        for neighbor_data in neighbors:
            # Safe unpacking for variable length tuples (Robustness)
            neighbor_id = neighbor_data[0]
            dist = neighbor_data[1]
            is_walk = neighbor_data[2]
            is_drive = neighbor_data[3]
            # indices 4 and 5 are geometry and highway_type, ignored here
            
            if mode == 'car' and not is_drive: continue
            if mode == 'walk' and not is_walk: continue
            
            curr_node = graph.nodes[current_id]
            neigh_node = graph.nodes[neighbor_id]
            ele_diff = neigh_node['ele'] - curr_node['ele']
            
            if mode == 'walk':
                edge_cost = get_tobler_time(dist, ele_diff)
            else:
                base_speed = 11.1 
                slope = ele_diff / dist if dist > 0 else 0
                
                if slope > 0.05: speed = base_speed * 0.8
                elif slope < -0.05: speed = base_speed * 1.1
                else: speed = base_speed
                
                edge_cost = dist / speed
            
            tentative_g = g_score[current_id] + edge_cost

            if tentative_g < g_score[neighbor_id]:
                came_from[neighbor_id] = current_id
                g_score[neighbor_id] = tentative_g
                f = tentative_g + heuristic_time(graph.nodes[neighbor_id], graph.nodes[end_id], mode)
                f_score[neighbor_id] = f
                open_set.push((f, neighbor_id))

    return None, float('inf') 

def reconstruct_path(came_from, current):
    total_path = [current]
    while current in came_from:
        current = came_from[current]
        total_path.append(current)
    return total_path[::-1]

def multi_stop_route(graph, stops, mode='car'):
    full_path = []
    total_cost = 0
    for i in range(len(stops) - 1):
        start = stops[i]
        end = stops[i+1]
        segment_path, segment_cost = a_star_search(graph, start, end, mode)
        if not segment_path: return None, float('inf')
        if i > 0: full_path.extend(segment_path[1:])
        else: full_path.extend(segment_path)
        total_cost += segment_cost
    return full_path, total_cost

# FILE END: algorithms.py
################################################################################

################################################################################
# FILE START: D:\dsa_sem_proj\data_pipeline.py
################################################################################

import requests
import osmnx as ox
import json
import os
import xml.etree.ElementTree as ET
from shapely.geometry import mapping
import time

# --- Configuration ---
CENTER_LAT = 33.6425
CENTER_LON = 72.9930
RADIUS = 2000 

# Files
RAW_MAP_FILE = "nust_raw.osm"
NODES_FILE = "nodes.json"
EDGES_FILE = "edges.json"
POIS_FILE = "pois.json"
ELEVATION_API = "https://api.open-elevation.com/api/v1/lookup"

def download_raw_map_data():
    print(f"[1/5] Downloading Real-World Map Data...")
    
    servers = [
        "https://overpass-api.de/api/interpreter",
        "https://overpass.kumi.systems/api/interpreter",
    ]

    # Query: Get everything with a name OR a barrier (Gates)
    overpass_query = f"""
    [out:xml][timeout:90];
    (
      way["highway"](around:{RADIUS},{CENTER_LAT},{CENTER_LON});
      node["name"](around:{RADIUS},{CENTER_LAT},{CENTER_LON});
      node["barrier"](around:{RADIUS},{CENTER_LAT},{CENTER_LON}); 
      way["name"](around:{RADIUS},{CENTER_LAT},{CENTER_LON});
    );
    (._;>;);
    out meta;
    """
    
    for url in servers:
        try:
            print(f"      Trying server: {url} ...")
            response = requests.get(url, params={'data': overpass_query}, stream=True, timeout=90)
            if response.status_code == 200:
                with open(RAW_MAP_FILE, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=1024):
                        if chunk: f.write(chunk)
                print(f"      Success! Saved raw map to '{RAW_MAP_FILE}'")
                return True
        except Exception as e:
            print(f"      Connection failed: {e}")
    return False

def process_graph_locally():
    print(f"[2/5] Building Road Network (Graph)...")
    if not os.path.exists(RAW_MAP_FILE):
        raise FileNotFoundError("Raw map file not found.")
    
    # 1. Load Graph
    G = ox.graph_from_xml(RAW_MAP_FILE)
    
    # 2. CRITICAL: DO NOT SIMPLIFY "BARRIER" NODES
    # Simplifying removes the "Gate" node because it's just a dot on a line.
    # We skip simplification to keep the exact gate locations.
    print("      Skipping simplification to preserve Gate nodes...")
    
    return G

def extract_pois_from_xml():
    print(f"[3/5] Extracting POIs from OSM Tags...")
    pois = []
    try:
        tree = ET.parse(RAW_MAP_FILE)
        root = tree.getroot()
        
        for node in root.findall('node'):
            tags = {tag.get('k'): tag.get('v') for tag in node.findall('tag')}
            
            name = tags.get('name')
            barrier = tags.get('barrier')
            amenity = tags.get('amenity')
            
            # Intelligent Naming
            final_name = name
            poi_type = "Location"

            if barrier in ['gate', 'entrance', 'toll_booth']:
                poi_type = "Entrance"
                if not final_name: final_name = f"Gate ({node.get('id')})"
            
            if amenity: poi_type = amenity

            if final_name:
                pois.append({
                    "name": final_name,
                    "lat": float(node.get('lat')),
                    "lon": float(node.get('lon')),
                    "type": poi_type
                })
    except Exception as e:
        print(f"      Warning: XML parsing issue ({e}).")

    print(f"      Found {len(pois)} POIs.")
    return pois

def build_database(G):
    print("[4/5] Processing Topology & Elevation...")
    nodes_export = {}
    edges_export = []
    
    node_ids = []
    api_payload = []
    
    # Nodes
    for n_id, data in G.nodes(data=True):
        nodes_export[n_id] = {
            "id": n_id,
            "lat": data['y'],
            "lon": data['x'],
            "elevation": 508
        }
        node_ids.append(n_id)
        api_payload.append({"latitude": data['y'], "longitude": data['x']})

    # Elevation (Sample limited for speed)
    subset = api_payload[:300] 
    try:
        resp = requests.post(ELEVATION_API, json={"locations": subset}, timeout=5)
        if resp.status_code == 200:
            for i, res in enumerate(resp.json()['results']):
                nodes_export[node_ids[i]]['elevation'] = res['elevation']
    except: pass

    # Edges
    for u, v, data in G.edges(data=True):
        hw = data.get('highway', '')
        
        # --- SMART CLASSIFICATION ---
        is_walk = True
        is_car = True
        
        # Motorways are for cars only
        if hw in ['motorway', 'motorway_link', 'trunk', 'trunk_link']:
            is_walk = False
        
        # Paths are for walking only
        if hw in ['footway', 'path', 'steps', 'pedestrian']:
            is_car = False
            
        # Service roads (Campus) are BOTH
        if hw in ['service', 'residential', 'unclassified']:
            is_car = True
            is_walk = True

        length = float(data.get('length', 0)) if not isinstance(data.get('length'), list) else float(data.get('length')[0])
        
        # Save the highway type so we can use it in structures.py
        edges_export.append({
            "u": u, "v": v, "weight": length,
            "is_walkable": is_walk, "is_drivable": is_car,
            "highway": hw, # <--- NEW FIELD
            "geometry": [] # Simplified for this snippet
        })

    return nodes_export, edges_export

def save_data(nodes, edges, pois):
    print(f"[5/5] Saving Database...")
    with open(NODES_FILE, 'w') as f: json.dump(nodes, f, indent=2)
    with open(EDGES_FILE, 'w') as f: json.dump(edges, f, indent=2)
    with open(POIS_FILE, 'w') as f: json.dump(pois, f, indent=2)
    print("Done.")

if __name__ == "__main__":
    if download_raw_map_data():
        G = process_graph_locally()
        pois = extract_pois_from_xml()
        nodes, edges = build_database(G)
        save_data(nodes, edges, pois)
    else:
        print("Pipeline Aborted.")

# FILE END: data_pipeline.py
################################################################################

################################################################################
# FILE START: D:\dsa_sem_proj\main.py
################################################################################

from structures import CityGraph
from algorithms import a_star_search
from visualizer import visualize_path

def get_user_selection(pois_list, prompt_text):
    """
    CLI for searching POIs. Returns (lat, lon, name).
    """
    while True:
        print(f"\n--- {prompt_text} ---")
        query = input("Search Location (e.g., 'Cafe', 'Library', 'Gate'): ").lower().strip()
        
        # Fuzzy search
        matches = [p for p in pois_list if query in p['name'].lower()]
        
        if not matches:
            print("No matches found. Try again.")
            continue
            
        # Display results
        print(f"Found {len(matches)} matches:")
        # Limit to top 5
        for i, p in enumerate(matches[:5]):
            print(f"  {i+1}. {p['name']} ({p['type']})")
            
        try:
            choice = int(input("Select number (0 to search again): "))
            if choice == 0: continue
            if 1 <= choice <= len(matches):
                selected = matches[choice-1]
                return selected['lat'], selected['lon'], selected['name']
            else:
                print("Invalid number.")
        except ValueError:
            print("Please enter a number.")

def calculate_stats(graph, path):
    total_climb = 0
    total_descent = 0
    for i in range(len(path) - 1):
        u = graph.nodes[path[i]]
        v = graph.nodes[path[i+1]]
        diff = v['ele'] - u['ele']
        if diff > 0: total_climb += diff
        else: total_descent += abs(diff)
    return total_climb, total_descent

def main():
    print("=== NUST Intelligent Navigation System ===")
    
    city = CityGraph()
    # Ensure pois.json is generated by data_pipeline.py first
    city.load_data('nodes.json', 'edges.json', 'pois.json')
    
    if not city.pois:
        print("CRITICAL: No POIs loaded. Run data_pipeline.py first!")
        return

    # 1. Interactive Input
    start_lat, start_lon, start_name = get_user_selection(city.pois, "Select START Point")
    end_lat, end_lon, end_name = get_user_selection(city.pois, "Select DESTINATION")
    
    # 2. Mode Selection
    print("\nSelect Transport Mode:")
    print("  1. Walking (Optimizes for Flat Terrain)")
    print("  2. Driving (Optimizes for Speed)")
    m_choice = input("Choice (1/2): ")
    mode = 'walk' if m_choice == '1' else 'car'
    
    print(f"\n[Process] Snapping '{start_name}' to nearest {mode} road...")
    start_id = city.find_nearest_node(start_lat, start_lon, mode=mode)
    end_id = city.find_nearest_node(end_lat, end_lon, mode=mode)
    
    print(f"[Process] Calculating {mode.upper()} route...")
    path, time_cost = a_star_search(city, start_id, end_id, mode=mode)

    if not path:
        print("Error: No path found.")
        return

    # 3. Analytics
    minutes = time_cost / 60.0
    climb, descent = calculate_stats(city, path)
    
    print(f"\n[Results] Trip to {end_name}:")
    print(f" - Estimated Time: {minutes:.1f} min")
    print(f" - Total Climb: {climb:.1f} meters")
    
    # 4. Nearby POIs
    print("\n[POI] Services along route:")
    found_pois = []
    for i in range(0, len(path), 10): # Scan every 10th node
        n = city.get_node(path[i])
        found_pois.extend(city.spatial.get_nearby(n['lat'], n['lon']))

    # Filter unique and exclude Start/End
    unique_pois = {p['name']: p for p in found_pois if p['name'] not in [start_name, end_name]}.values()
    
    if unique_pois:
        for p in list(unique_pois)[:5]: # Show max 5
            print(f" - {p['name']}")
    else:
        print(" - None found.")

    visualize_path(city, path, list(unique_pois))

if __name__ == "__main__":
    main()

# FILE END: main.py
################################################################################

################################################################################
# FILE START: D:\dsa_sem_proj\structures.py
################################################################################

import json

class MinHeap:
    def __init__(self): self.heap = []
    def push(self, item):
        self.heap.append(item)
        self._sift_up(len(self.heap) - 1)
    def pop(self):
        if not self.heap: return None
        root = self.heap[0]
        last = self.heap.pop()
        if self.heap:
            self.heap[0] = last
            self._sift_down(0)
        return root
    def is_empty(self): return len(self.heap) == 0
    def _sift_up(self, index):
        parent_idx = (index - 1) // 2
        if index > 0 and self.heap[index][0] < self.heap[parent_idx][0]:
            self.heap[index], self.heap[parent_idx] = self.heap[parent_idx], self.heap[index]
            self._sift_up(parent_idx)
    def _sift_down(self, index):
        smallest = index
        left = 2 * index + 1
        right = 2 * index + 2
        if left < len(self.heap) and self.heap[left][0] < self.heap[smallest][0]: smallest = left
        if right < len(self.heap) and self.heap[right][0] < self.heap[smallest][0]: smallest = right
        if smallest != index:
            self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index]
            self._sift_down(smallest)

class SpatialGrid:
    def __init__(self, cell_size=0.005): 
        self.cell_size = cell_size
        self.grid = {} 
    def add_poi(self, name, lat, lon, type_tag):
        key = (int(lat/self.cell_size), int(lon/self.cell_size))
        if key not in self.grid: self.grid[key] = []
        self.grid[key].append({'name': name, 'lat': lat, 'lon': lon, 'type': type_tag})
    def get_nearby(self, lat, lon):
        ck = (int(lat/self.cell_size), int(lon/self.cell_size))
        nearby = []
        for dx in [-1,0,1]:
            for dy in [-1,0,1]:
                k = (ck[0]+dx, ck[1]+dy)
                if k in self.grid: nearby.extend(self.grid[k])
        return nearby

class CityGraph:
    def __init__(self):
        self.nodes = {}   
        self.adj_list = {} 
        self.spatial = SpatialGrid()
        self.drive_nodes = set()
        self.walk_nodes = set()
        self.pois = [] 

    def load_data(self, nodes_file, edges_file, pois_file="pois.json"):
        print("Loading graph data...")
        with open(nodes_file, 'r') as f:
            nodes_data = json.load(f)
        for n_id, data in nodes_data.items():
            node_id = int(n_id) 
            self.nodes[node_id] = {'lat': data['lat'], 'lon': data['lon'], 'ele': data.get('elevation', 0)}
            self.adj_list[node_id] = [] 

        with open(edges_file, 'r') as f:
            edges_data = json.load(f)
        for edge in edges_data:
            u, v = int(edge['u']), int(edge['v'])
            if u in self.nodes and v in self.nodes:
                # Store highway type in the tuple for later checking
                # (v, weight, is_walk, is_drive, geometry, highway_type)
                self.adj_list[u].append((v, edge['weight'], edge['is_walkable'], edge['is_drivable'], edge['geometry'], edge.get('highway', '')))
                
                if edge['is_drivable']:
                    self.drive_nodes.add(u); self.drive_nodes.add(v)
                if edge['is_walkable']:
                    self.walk_nodes.add(u); self.walk_nodes.add(v)
        
        try:
            with open(pois_file, 'r') as f: self.pois = json.load(f)
            for p in self.pois: self.spatial.add_poi(p['name'], p['lat'], p['lon'], p['type'])
        except: pass

    # UPDATED: Returns 5 items now
    def get_neighbors(self, node_id): return self.adj_list.get(node_id, [])
    def get_node(self, node_id): return self.nodes.get(node_id)
    
    # --- THE SMART SNAP ALGORITHM ---
    def find_nearest_node(self, target_lat, target_lon, mode='car'):
        candidates = [] # Store (distance, node_id)
        
        pool = self.drive_nodes if mode == 'car' else self.walk_nodes
        if not pool: pool = self.nodes.keys()

        # 1. Find the top 10 closest nodes mathematically
        for node_id in pool:
            if node_id not in self.nodes: continue
            data = self.nodes[node_id]
            d_lat = data['lat'] - target_lat
            d_lon = data['lon'] - target_lon
            dist_sq = d_lat**2 + d_lon**2
            
            # Optimization: only keep if reasonably close (e.g., within ~200m)
            if dist_sq < 0.00001: 
                candidates.append((dist_sq, node_id))
        
        candidates.sort(key=lambda x: x[0])
        top_candidates = candidates[:5] # Check top 5 closest
        
        if not top_candidates: return None
        
        # 2. Pick the best one based on Topology
        best_node = top_candidates[0][1] # Default to closest
        
        for dist, node_id in top_candidates:
            # Check the edges connected to this node
            neighbors = self.adj_list.get(node_id, [])
            
            # If we are looking for an entrance, prefer 'service' or 'residential'
            # Penalize 'motorway' or 'trunk' (The Highway)
            
            is_highway = False
            is_campus_road = False
            
            for n in neighbors:
                hw_type = n[5] # Index 5 is highway type
                if hw_type in ['motorway', 'trunk', 'primary', 'secondary']:
                    is_highway = True
                if hw_type in ['service', 'residential', 'living_street']:
                    is_campus_road = True
            
            # LOGIC: If the node connects to a campus road, PICK IT immediately.
            # Even if it's 2nd or 3rd closest.
            if is_campus_road:
                return node_id
                
        return best_node

# FILE END: structures.py
################################################################################

################################################################################
# FILE START: D:\dsa_sem_proj\test_algorithms.py
################################################################################

from structures import CityGraph
from algorithms import a_star_search, multi_stop_route
import random

def get_distant_node(graph, start_node, steps=10):
    """
    Performs a random walk to find a valid node 'steps' away.
    This ensures start != end.
    """
    current = start_node
    for _ in range(steps):
        neighbors = graph.get_neighbors(current)
        if not neighbors:
            break
        # Pick a random neighbor to avoid bouncing back and forth (A->B->A)
        next_node = random.choice(neighbors)[0] 
        current = next_node
    return current

def run_test():
    # 1. Load Graph
    city = CityGraph()
    city.load_data('nodes.json', 'edges.json')
    
    # 2. Pick a valid Start Node (ensure it has neighbors)
    all_ids = list(city.nodes.keys())
    start_node = None
    for nid in all_ids:
        if city.get_neighbors(nid):
            start_node = nid
            break
            
    if not start_node:
        print("Error: Graph has no edges!")
        return

    # 3. Find a distant End Node (Walk 10 steps away)
    end_node = get_distant_node(city, start_node, steps=10)

    if start_node == end_node:
        print("Could not find a distant node (Graph might be too small or disconnected).")
        return

    print(f"\n--- Test 1: Basic A* (Car) ---")
    print(f"Start: {start_node} -> End: {end_node}")
    
    path, cost = a_star_search(city, start_node, end_node, mode='car')
    
    if path:
        print(f"Path Found! Steps: {len(path)}")
        print(f"Cost: {cost:.2f}")
        # Print first 5 and last 5 nodes to keep output clean
        if len(path) > 10:
            print(f"Route: {path[:3]} ... {path[-3:]}")
        else:
            print(f"Route: {path}")
    else:
        print("No path found (Nodes might be in different sub-graphs).")
        return

    print(f"\n--- Test 2: Topography Check (Walk vs Car) ---")
    path_w, cost_w = a_star_search(city, start_node, end_node, mode='walk')
    
    print(f"Car Cost:  {cost:.2f}")
    print(f"Walk Cost: {cost_w:.2f}")
    
    # Logic Check
    if cost_w > cost:
        diff = cost_w - cost
        print(f">> SUCCESS: Walking is penalized by {diff:.2f} (due to elevation/terrain).")
    elif cost_w == cost:
        print(">> NOTE: Costs are equal (Path is perfectly flat).")
    else:
        print(">> WEIRD: Walking is cheaper? Check cost function.")

    print(f"\n--- Test 3: Multi-Stop Routing ---")
    # Route: Start -> End -> Start
    stops = [start_node, end_node, start_node]
    m_path, m_cost = multi_stop_route(city, stops, mode='car')
    
    if m_path:
        print(f"Multi-stop path length: {len(m_path)}")
        print(f"Total Cost: {m_cost:.2f}")
    else:
        print("Multi-stop failed.")

if __name__ == "__main__":
    run_test()

# FILE END: test_algorithms.py
################################################################################

################################################################################
# FILE START: D:\dsa_sem_proj\test_structures.py
################################################################################

from structures import CityGraph, MinHeap

def test_graph_loading():
    print("--- Testing Graph Loading ---")
    city = CityGraph()
    city.load_data('nodes.json', 'edges.json')
    
    # Check if we have nodes
    total_nodes = len(city.nodes)
    print(f"Graph Nodes: {total_nodes}")
    
    if total_nodes > 0:
        first_node_id = list(city.nodes.keys())[0]
        print(f"Sample Node {first_node_id}: {city.get_node(first_node_id)}")
        print(f"Neighbors: {city.get_neighbors(first_node_id)}")
    
    # Test Spatial Hashing
    print("\n--- Testing POI Search ---")
    # Pick a random node's location
    sample_node = city.get_node(list(city.nodes.keys())[100]) 
    pois = city.spatial.get_nearby(sample_node['lat'], sample_node['lon'])
    print(f"POIs near Node 100: {pois}")

def test_heap():
    print("\n--- Testing MinHeap Implementation ---")
    pq = MinHeap()
    pq.push((10, 'A'))
    pq.push((5, 'B'))
    pq.push((20, 'C'))
    pq.push((2, 'D')) # Smallest
    
    print("Popping items (should be 2, 5, 10, 20):")
    while not pq.is_empty():
        print(pq.pop())

if __name__ == "__main__":
    test_graph_loading()
    test_heap()

# FILE END: test_structures.py
################################################################################

################################################################################
# FILE START: D:\dsa_sem_proj\visualizer.py
################################################################################

import json
import os
import webbrowser

def visualize_path(graph, path: list, pois: list = [], output_file: str = "map.html"):
    """
    Generates a modern MapLibre GL JS map using OpenFreeMap tiles.
    Overlays the Python-calculated A* path and POIs.
    """
    if not path:
        print("No path to visualize.")
        return

    # 1. Convert Path to GeoJSON LineString
    # MapLibre/GeoJSON expects [lon, lat], NOT [lat, lon]
    route_coords = []
    
    for i in range(len(path) - 1):
        u_id = path[i]
        v_id = path[i+1]
        
        # Get geometry from the edge data
        # neighbors list structure: (neighbor_id, weight, is_walk, is_drive, geometry)
        neighbors = graph.get_neighbors(u_id)
        edge_geometry = []
        
        found_edge = False
        for n in neighbors:
            if n[0] == v_id:
                edge_geometry = n[4] # This is stored as [[lat, lon], ...] in structures.py
                found_edge = True
                break
        
        if found_edge and edge_geometry:
            # Swap to [lon, lat] for GeoJSON
            segment = [[pt[1], pt[0]] for pt in edge_geometry]
            route_coords.extend(segment)
        else:
            # Fallback to straight line if geometry is missing
            n1 = graph.get_node(u_id)
            n2 = graph.get_node(v_id)
            if n1 and n2:
                route_coords.append([n1['lon'], n1['lat']])
                route_coords.append([n2['lon'], n2['lat']])

    # Handle single node path or start point
    if not route_coords and len(path) == 1:
        n = graph.get_node(path[0])
        route_coords.append([n['lon'], n['lat']])

    # 2. Prepare POIs as GeoJSON FeatureCollection
    poi_features = []
    for p in pois:
        poi_features.append({
            "type": "Feature",
            "geometry": {
                "type": "Point",
                "coordinates": [p['lon'], p['lat']]
            },
            "properties": {
                "name": p['name'],
                "type": p.get('type', 'POI')
            }
        })

    # 3. Calculate Map Center
    start_node = graph.get_node(path[0])
    center_lon = start_node['lon']
    center_lat = start_node['lat']

    # 4. Generate the HTML (Using MapLibre + OpenFreeMap Style)
    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8" />
        <title>NUST Intelligent Navigation</title>
        <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
        <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>
        <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />
        <style>
            body {{ margin: 0; padding: 0; }}
            #map {{ position: absolute; top: 0; bottom: 0; width: 100%; }}
            .legend {{
                background-color: #fff;
                border-radius: 3px;
                bottom: 30px;
                box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
                font: 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
                padding: 10px;
                position: absolute;
                right: 10px;
                z-index: 1;
            }}
        </style>
    </head>
    <body>
        <div id="map"></div>
        <div class="legend">
            <h4>Route Analytics</h4>
            <div><span style="background-color: #3b82f6; width: 10px; height: 10px; display: inline-block;"></span> Calculated Path</div>
            <div><span style="background-color: #ef4444; width: 10px; height: 10px; display: inline-block;"></span> POIs</div>
        </div>
        <script>
            const map = new maplibregl.Map({{
                container: 'map',
                style: 'https://tiles.openfreemap.org/styles/liberty', 
                center: [{center_lon}, {center_lat}],
                zoom: 14
            }});

            map.on('load', () => {{
                
                // LAYER 1: The Path
                map.addSource('route', {{
                    'type': 'geojson',
                    'data': {{
                        'type': 'Feature',
                        'properties': {{}},
                        'geometry': {{
                            'type': 'LineString',
                            'coordinates': {json.dumps(route_coords)}
                        }}
                    }}
                }});
                
                map.addLayer({{
                    'id': 'route',
                    'type': 'line',
                    'source': 'route',
                    'layout': {{
                        'line-join': 'round',
                        'line-cap': 'round'
                    }},
                    'paint': {{
                        'line-color': '#3b82f6',
                        'line-width': 6,
                        'line-opacity': 0.8
                    }}
                }});

                // LAYER 2: POIs
                map.addSource('pois', {{
                    'type': 'geojson',
                    'data': {{
                        'type': 'FeatureCollection',
                        'features': {json.dumps(poi_features)}
                    }}
                }});

                map.addLayer({{
                    'id': 'pois',
                    'type': 'circle',
                    'source': 'pois',
                    'paint': {{
                        'circle-radius': 8,
                        'circle-color': '#ef4444',
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff'
                    }}
                }});

                // Add popups on click for POIs
                map.on('click', 'pois', (e) => {{
                    const coordinates = e.features[0].geometry.coordinates.slice();
                    const name = e.features[0].properties.name;
                    new maplibregl.Popup()
                        .setLngLat(coordinates)
                        .setHTML('<strong>' + name + '</strong>')
                        .addTo(map);
                }});

                // Change cursor on hover
                map.on('mouseenter', 'pois', () => {{
                    map.getCanvas().style.cursor = 'pointer';
                }});
                map.on('mouseleave', 'pois', () => {{
                    map.getCanvas().style.cursor = '';
                }});
                
                // Fit bounds to route
                const coords = {json.dumps(route_coords)};
                if (coords.length > 0) {{
                    const bounds = coords.reduce((bounds, coord) => {{
                        return bounds.extend(coord);
                    }}, new maplibregl.LngLatBounds(coords[0], coords[0]));
                    map.fitBounds(bounds, {{ padding: 50 }});
                }}
            }});
        </script>
    </body>
    </html>
    """

    with open(output_file, "w") as f:
        f.write(html_content)
    
    print(f"Map generated: {output_file} (Using OpenFreeMap Tiles)")
    webbrowser.open('file://' + os.path.realpath(output_file))

# FILE END: visualizer.py
################################################################################
